
local fil = io.open("lgl.cpp", "w")

fil:write(
[[
/*********************************
  This file is automatically generated by LGL
  
  http://github.com/zorbathut/lgl
  
  You probably shouldn't edit it manually.
*********************************/

#include <map>
#include <string>
#include <algorithm>

#include <cassert>

#include "GLee.h"
#include "lua.h"
#include "lauxlib.h"

#include <stdarg.h>
#include <stdlib.h>

using namespace std;

static void std_error(lua_State *L, const char *helpdocs, const char *msg, ...) __attribute__((format(printf,3,4)));
static void std_error(lua_State *L, const char *helpdocs, const char *msg, ...) {
  char buf[2048];
  strcpy(buf, helpdocs);
  int len = strlen(buf);
  va_list args;
  va_start(args, msg);
  vsnprintf(buf + len, sizeof(buf) - len, msg, args);
  va_end(args);
  buf[sizeof(buf) - 1] = '\0'; // who bloody well knows
  luaL_error(L, buf);
}

template<typename T> void *snagTable(lua_State *L, int index, int *ct_out = NULL) {
  int ct = lua_objlen(L, index);
  T *memblock = (T*)malloc(sizeof(T) * ct);
  for(int i = 0; i < ct; i++) {
    lua_pushnumber(L, i + 1);
    lua_gettable(L, index);
    memblock[i] = (T)lua_tonumber(L, -1);
    lua_pop(L, 1);
  }
  if(ct_out)
    *ct_out = ct;
  return (void*)memblock;
}

]])

local types = {}
types.float = {
  stdprocess = 
[[if(!(lua_isnumber(L, INDEX)))
  std_error(L, HELP, "Parameter type mismatch in FUNCNAME for parameter PARAMNAME");
PARAMNAME = lua_tonumber(L, INDEX);]],
  type = "GLfloat",
}
types.enum = {
  stdprocess = 
[[if(!(lua_isstring(L, INDEX)))
  std_error(L, HELP, "Parameter type mismatch in FUNCNAME for parameter PARAMNAME");
PARAMNAME = enum_retrieve(lua_tostring(L, INDEX));
if(PARAMNAME == (GLenum)-1)
  std_error(L, HELP, "Unknown enum in FUNCNAME for parameter PARAMNAME: %s", lua_tostring(L, INDEX));]],
  type = "GLenum",
}
types.int = {
  stdprocess = 
[[if(!(lua_isnumber(L, INDEX)))
  std_error(L, HELP, "Parameter type mismatch in FUNCNAME for parameter PARAMNAME");
PARAMNAME = lua_tonumber(L, INDEX);
if((double)PARAMNAME != lua_tonumber(L, INDEX))
  std_error(L, HELP, "Non-integer in FUNCNAME for parameter PARAMNAME: %s", lua_tostring(L, INDEX));]],
  type = "GLint",
}
types.bool = {
  stdprocess = 
[[if(!(lua_isboolean(L, INDEX)))
  std_error(L, HELP, "Parameter type mismatch in FUNCNAME for parameter PARAMNAME");
PARAMNAME = lua_toboolean(L, INDEX);]],
  type = "GLboolean",
}

types.typed_data_type = {
  stdprocess = types.enum.stdprocess,
  type = types.enum.type,
  name = "type",
}
types.typed_data = {
  stdprocess =
[[if(type == GL_UNSIGNED_BYTE || type == GL_BYTE || type == GL_UNSIGNED_BYTE_3_3_2 || type == GL_UNSIGNED_BYTE_2_3_3_REV)
  PARAMNAME = snagTable<unsigned char>(L, INDEX);
else if(type == GL_UNSIGNED_SHORT || type == GL_SHORT || type == GL_UNSIGNED_SHORT_5_6_5 || type == GL_UNSIGNED_SHORT_5_6_5_REV || type == GL_UNSIGNED_SHORT_4_4_4_4 || type == GL_UNSIGNED_SHORT_4_4_4_4_REV || type == GL_UNSIGNED_SHORT_5_5_5_1 || type == GL_UNSIGNED_SHORT_1_5_5_5_REV || type == GL_2_BYTES)
  PARAMNAME = snagTable<short>(L, INDEX);
else if(type == GL_UNSIGNED_INT || type == GL_INT || type == GL_UNSIGNED_INT_8_8_8_8 || type == GL_UNSIGNED_INT_8_8_8_8_REV || type == GL_UNSIGNED_INT_10_10_10_2 || type == GL_UNSIGNED_INT_2_10_10_10_REV || type == GL_4_BYTES)
  PARAMNAME = snagTable<int>(L, INDEX);
else if(type == GL_FLOAT)
  PARAMNAME = snagTable<float>(L, INDEX);
else if(type == GL_BITMAP)
  std_error(L, HELP, "GL_BITMAP not supported in FUNCNAME");
else if(type == GL_3_BYTES)
  std_error(L, HELP, "GL_3_BYTES not supported in FUNCNAME");
else
  std_error(L, HELP, "Unrecognized type in FUNCNAME");]],
  stdcleanup = [[free(PARAMNAME);]],
  type = "void *",
}

types.rawdata_alignment = {
  stdprocess =
[[if(!(lua_isstring(L, INDEX)))
  std_error(L, HELP, "Parameter type mismatch in FUNCNAME for parameter PARAMNAME");
GLenum alignment = enum_retrieve(lua_tostring(L, INDEX));
if(alignment == (GLenum)-1)
  std_error(L, HELP, "Unknown alignment in FUNCNAME for parameter INDEX: %s", lua_tostring(L, INDEX));]],
  type = {}
}
types.rawdata_table = {
  stdprocess =
[[if(alignment == GL_UNSIGNED_BYTE || alignment == GL_BYTE) {
  PARAMNAME2 = snagTable<unsigned char>(L, INDEX, &PARAMNAME1);
} else if(alignment == GL_UNSIGNED_SHORT || alignment == GL_SHORT) {
  PARAMNAME2 = snagTable<short>(L, INDEX, &PARAMNAME1);
  PARAMNAME1 = PARAMNAME1 * sizeof(short);
} else if(alignment == GL_UNSIGNED_INT || alignment == GL_INT) {
  PARAMNAME2 = snagTable<int>(L, INDEX, &PARAMNAME1);
  PARAMNAME1 = PARAMNAME1 * sizeof(int);
} else if(alignment == GL_FLOAT) {
  PARAMNAME2 = snagTable<float>(L, INDEX, &PARAMNAME1);
  PARAMNAME1 = PARAMNAME1 * sizeof(float);
} else
  std_error(L, HELP, "Unrecognized type in FUNCNAME");]],
  type = {"int", "void *"},
}
types.rawdata_table_indexed = {
  stdprocess =
[[if(alignment == GL_UNSIGNED_BYTE || alignment == GL_BYTE) {
  PARAMNAME2 = snagTable<unsigned char>(L, INDEX, &PARAMNAME1);
} else if(alignment == GL_UNSIGNED_SHORT || alignment == GL_SHORT) {
  PARAMNAME2 = snagTable<short>(L, INDEX, &PARAMNAME1);
  PARAMNAME1 = PARAMNAME1 * sizeof(short);
  index = index * sizeof(short);
} else if(alignment == GL_UNSIGNED_INT || alignment == GL_INT) {
  PARAMNAME2 = snagTable<int>(L, INDEX, &PARAMNAME1);
  PARAMNAME1 = PARAMNAME1 * sizeof(int);
  index = index * sizeof(int);
} else if(alignment == GL_FLOAT) {
  PARAMNAME2 = snagTable<float>(L, INDEX, &PARAMNAME1);
  PARAMNAME1 = PARAMNAME1 * sizeof(float);
  index = index * sizeof(float);
} else
  std_error(L, HELP, "Unrecognized type in FUNCNAME");]],
  type = {"int", "void *"},
}

types.index = {
  stdprocess = 
[[if(!(lua_isnumber(L, INDEX)))
  std_error(L, HELP, "Parameter type mismatch in FUNCNAME for parameter PARAMNAME");
PARAMNAME = lua_tonumber(L, INDEX);
if((double)PARAMNAME != lua_tonumber(L, INDEX))
  std_error(L, HELP, "Non-integer in FUNCNAME for parameter PARAMNAME: %s", lua_tostring(L, INDEX));
PARAMNAME = PARAMNAME + 1;]],
  type = "GLint",
}
types.int_or_enum = {
  stdprocess = 
[[if(lua_isnumber(L, INDEX)) {
  PARAMNAME = lua_tonumber(L, INDEX);
  if((double)PARAMNAME != lua_tonumber(L, INDEX))
    std_error(L, HELP, "Non-integer in FUNCNAME for parameter PARAMNAME: %s", lua_tostring(L, INDEX));
} else if(lua_isstring(L, INDEX)) {
  PARAMNAME = (GLint)enum_retrieve(lua_tostring(L, INDEX));
  if(PARAMNAME == -1)
    std_error(L, HELP, "Unknown enum in FUNCNAME for parameter PARAMNAME: %s", lua_tostring(L, INDEX));
} else {
  std_error(L, HELP, "Parameter type mismatch in FUNCNAME for parameter PARAMNAME");
}]],
  type = "GLint",
}
types.table_data = {
  stdprocess =
[[if(!(lua_istable(L, INDEX)))
  std_error(L, HELP, "Parameter type mismatch in FUNCNAME for parameter PARAMNAME");]],
  type = "void *",
  custom = true,
}
types.enum_custom = {
  type = "GLenum",
  custom = true,
}
types.string = {
  stdprocess =
[[if(!(lua_isstring(L, INDEX)))
  std_error(L, HELP, "Parameter type mismatch in FUNCNAME for parameter PARAMNAME");
PARAMNAME = (GLchar*)lua_tostring(L, INDEX);]],
  type = "GLchar *",
}
types.bitmask = {
  stdprocess =
[[if(!(lua_isstring(L, INDEX)))
  std_error(L, HELP, "Parameter type mismatch in FUNCNAME for parameter PARAMNAME");
PARAMNAME = enum_bitmask_retrieve(lua_tostring(L, INDEX));
if(PARAMNAME == (GLenum)-1)
  std_error(L, HELP, "Unknown enum in FUNCNAME for parameter PARAMNAME: %s", lua_tostring(L, INDEX));]],
  type = "GLenum",
}

types.program = types.int
types.shader = types.int
types.query = types.int
types.list = types.int

local data
do
  local descriptor_table = {}
  
  for k in pairs(types) do
    descriptor_table[k] = k
  end
  
  descriptor_table.table_fixed = function (typ, num)
    typ = "GL" .. typ
    local tok = "table_fixed_" .. typ .. "_" .. num
    
    if not types[tok] then
      types[tok] = {
        stdprocess =
([[if(!(lua_istable(L, INDEX)))
  std_error(L, HELP, "Parameter type mismatch in FUNCNAME for parameter PARAMNAME");
if(lua_objlen(L, INDEX) != FIXEDLEN)
  std_error(L, HELP, "Table size error in FUNCNAME for parameter PARAMNAME - Expected %d, got FIXEDLEN", lua_objlen(L, INDEX));
PARAMNAME = (TYPE*)snagTable<TYPE>(L, INDEX);]]):gsub("FIXEDLEN", tostring(num)):gsub("TYPE", typ),
        stdcleanup = [[free(PARAMNAME);]],
        type = typ .. " *",
      }
    end
    
    return tok
  end
  
  local eo_caps = {}
  descriptor_table.enum_offset = function (prefix, cap)
    local tok = "enum_offset_" .. prefix
    
    if eo_caps[prefix] then assert(eo_caps[prefix] == cap) end
    eo_caps[prefix] = cap
    
    if not types[tok] then
      types[tok] = {
        stdprocess =
([[if(!(lua_isnumber(L, INDEX)))
  std_error(L, HELP, "Parameter type mismatch in FUNCNAME for parameter PARAMNAME");
PARAMNAME = lua_tonumber(L, INDEX);
if(PARAMNAME <= 0 || PARAMNAME > GL_ENUMCAP)
  std_error(L, HELP, "ID out of bounds in FUNCNAME for parameter PARAMNAME");
PARAMNAME = PARAMNAME + GL_ENUMORIGIN0 - 1;]]):gsub("ENUMORIGIN", prefix):gsub("ENUMCAP", cap),
        type = "GLenum",
      }
    end
    
    return tok
  end
  
  local lf = assert(loadfile("descriptor_ogl1.lua"))
  setfenv(lf, descriptor_table)
  lf()
  data = descriptor_table.data
end

local enum_list = {}
local function pull_enums(v)
  -- list of enums in the function
  if v.enums then
    for id, typ in pairs(v.params) do
      if v.enums[id] then
        for enu in v.enums[id]:gmatch("([^%s]+)") do
          enum_list[enu] = true
        end
      end
    end
  end
end

-- we do a few things here, mostly generating lists of stuff
local ites = {}
for k, v in pairs(data) do
  -- list of the functions involved
  table.insert(ites, k)
  
  pull_enums(v)
  for _, chunk in ipairs(v) do
    if type(chunk) == "table" then
      pull_enums(chunk)
    end
  end
end
table.sort(ites)

-- alphabetize enum list, generate the enum init code
local enu_alpha = {}
for k in pairs(enum_list) do
  table.insert(enu_alpha, k)
end
table.sort(enu_alpha)
fil:write(
[[map<string, GLenum> enum_map;
map<GLenum, string> enum_map_reverse;

static void enum_add(GLenum enu, const string &text) {
  assert(enum_map.count(text) == 0);
  assert(enum_map_reverse.count(enu) == 0);
  
  assert(enu != (GLenum)-1);
  
  enum_map[text] = enu;
  enum_map_reverse[enu] = text;
}

static GLenum enum_retrieve(const string &text) {
  map<string, GLenum>::iterator itr = enum_map.find(text);
  if(itr != enum_map.end())
    return itr->second;
  return -1;
}

static GLenum enum_bitmask_retrieve(const string &text) {
  GLenum rv = 0;
  string::const_iterator st = text.begin();
  string::const_iterator ed = find(st, text.end(), ' ');
  while(st != text.end()) {
    rv = rv | enum_retrieve(string(st, ed));
    st = ed;
    if(st != text.end())
      st++;
    ed = find(st, text.end(), ' ');
  }
  return rv;
}

static void enum_init() {
]])
for _, v in pairs(enu_alpha) do
  fil:write("  enum_add(GL_" .. v .. ", \"" .. v .. "\");\n")
end
fil:write("}\n\n")


--[[ how shards look:

do {
  -- code blah blah
  if(failure) break;
}

do {
}

print_error_message();

-- and that's a bit different from the normal, more useful messages

]]

local function do_shard(dat, local_name, name)
-- first we check the parameter count
  fil:write("  do {\n\n")

  local paramincount = 0
  local paramlist = {}
  for id, typ in ipairs(dat.params) do
    local typcustom = dat.names and dat.names[id]
    local typbasic = types[typ].name
    local types = types[typ].type
    
    if type(typcustom) == "string" then typcustom = {typcustom} end
    if type(typbasic) == "string" then typbasic = {typbasic} end
    if type(types) == "string" then types = {types} end
    if typcustom then
      assert(#typcustom == #types)
    end
    if typbasic then
      assert(#typbasic == #types)
    end
    
    paramincount = paramincount + #types
    
    local realnames = {}
    for i = 1, #types do
      local def = "param" .. id
      if #types > 1 then
        def = def .. "_" .. i
      end
      table.insert(realnames, (typcustom and typcustom[i]) or (typbasic and typbasic[i]) or def)
    end
    
    table.insert(paramlist, realnames)
  end
  
  fil:write("    // first we check the parameter count\n") -- :D
  fil:write("    if(lua_gettop(L) != " .. paramincount .. ") {\n")
  fil:write("      break;\n")
  fil:write("    }\n\n")

  -- hee
  local convert = {}
  local function addsub(param, src, dst)
    local cp = convert[param]
    convert[param] = function(x) return cp(x):gsub(src, dst) end
  end
  for i = 1, #dat.params do
    convert[i] = function(x) return x end
    
    addsub(i, "\n", "\n    ")
    addsub(i, "FUNCNAME", "gl." .. name)
    addsub(i, "HELP", "help_" .. name)
  end
  
  -- now we do parameters
  for id, typ in ipairs(dat.params) do
    addsub(id, "INDEX", tostring(id))
    
    local tinfo = types[typ]
    if tinfo.custom then
      assert(dat.custom and dat.custom[id])
    end
    assert(tinfo)
    fil:write("    // extract parameter " .. id .. "\n")
    
    -- types
    do
      local tinf = tinfo.type
      if type(tinf) == "string" then tinf = {tinf} end
      
      for pid = 1, #tinf do
        addsub(id, "PARAMNAME" .. pid, paramlist[id][pid])
      
        fil:write("    " .. tinf[pid] .. " " .. paramlist[id][pid] .. ";\n")
      end
      
      if #tinf == 1 then
        addsub(id, "PARAMNAME", paramlist[id][1])
      end
    end
    
    if tinfo.stdprocess then
      fil:write("    " .. convert[id](tinfo.stdprocess) .. "\n\n")
    end
  end
  
  -- now we do custom parameter init
  if dat.custom then
    for id, typ in ipairs(dat.params) do
      local cst = dat.custom[id]
      if cst and cst.parse then
        local param = paramlist[id]
        fil:write("    // custom init code for parameter " .. id .. "\n")
        fil:write("    " .. convert[id](cst.parse) .. "\n\n")
      end
    end
  end
  
  -- actually call the function
  fil:write("    // actually call the function\n")
  local ln
  if dat.func then
    ln = dat.func
  elseif local_name then
    ln = "gl" .. local_name
  else
    ln = "gl" .. name
  end
  fil:write("    " .. ln .. "(")
  local first = true
  for id, chunk in ipairs(paramlist) do
    for _, name in pairs(chunk) do
      if not first then
        fil:write(", ")
      end
      fil:write(name)
      first = false
    end
  end
  fil:write(");\n\n")
  
  -- now we do custom parameter cleanup
  if dat.custom then
    for id, typ in ipairs(dat.params) do
      local cst = dat.custom[id]
      if cst and cst.cleanup then
        local param = paramlist[id]
        fil:write("    // custom cleanup code for parameter " .. id .. "\n")
        fil:write("    " .. convert[id](cst.cleanup) .. "\n\n")
      end
    end
  end

    -- now we do normal cleanup
  for id, typ in ipairs(dat.params) do
    local tinfo = types[typ]
    local param = paramlist[id]
    assert(tinfo)
    if tinfo.stdcleanup then
      fil:write("    // cleanup parameter " .. id .. "\n")
      fil:write("    " .. convert[id](tinfo.stdcleanup) .. "\n\n")
    end
  end
  
  fil:write("    return 0;\n")
  fil:write("  } while(false); // though actually if we get here something has gone very wrong\n\n")
end

for _, name in pairs(ites) do
  local dat = data[name]
  
  fil:write("static const char help_" .. name .. "[] = \"(gotta write help)\";\n")
  fil:write("static int lgl_" .. name .. "(lua_State *L) {\n\n")
  
  if #dat > 0 then
    for _, v in ipairs(dat) do
      if type(v) == "table" then
        do_shard(v, name, name)
      else
        do_shard(data[v], v, name)
      end
    end
  else
    do_shard(dat, name, name)
  end

  fil:write("  std_error(L, help_" .. name .. ", \"Incorrect number of parameters in gl." .. name .. ". Got %d\", lua_gettop(L));\n")
  
  fil:write("  return 0;\n")
  fil:write("}\n\n")
end


fil:write("\n\nstatic const luaL_reg lgl[] = {\n")
for _, v in pairs(ites) do
  fil:write('  {"' .. v .. '", lgl_' .. v .. '},\n')
end
fil:write("  {NULL, NULL}\n")
fil:write("};\n\n")

fil:write(
[[int luaopen_lgl(lua_State *L) {
  enum_init();
  luaL_openlib(L, "gl", lgl, 0);
  return 1;
}
]])

fil:close()
